#define STORE_GLOBAL_MAP
	[store_map_dimensions]
	[/store_map_dimensions]

	{VARIABLE i 0}
	{REPEAT $map_size.width| (
		[store_locations]
			y=$i
			variable=GN_GLOBAL_MAP[$i|].row
		[/store_locations]
		{VARIABLE_OP i add 1}
	)}
	{CLEAR_VARIABLE i}
#enddef

#define RESTORE_GLOBAL_MAP
	{FOREACH GN_GLOBAL_MAP i}
		[set_variable]
			name=row[$i|].string
			[join]
				variable=GN_GLOBAL_MAP[$i|].row
				key=terrain
				separator=","
				remove_empty=no
			[/join]
		[/set_variable]
	{NEXT i}

	[set_variable]
		name=map_data
		[join]
			variable=row
			key=string
			separator="
"
			remove_empty=yes
		[/join]
	[/set_variable]

	[replace_map]
		map="$map_data"
		expand=yes
		shrink=yes
	[/replace_map]

	{CLEAR_VARIABLE i}
	{CLEAR_VARIABLE map_data}
	{CLEAR_VARIABLE row}
#enddef

#define GENERATE_LOCAL_MAP ATTACKER_X ATTACKER_Y DEFENDER_X DEFENDER_Y 
	# store the immediate surroundings in a pallette
	[lua]
		[args]
			x1,y1={ATTACKER_X},{ATTACKER_Y}
			x2,y2={DEFENDER_X},{DEFENDER_Y}
		[/args]
		code=<<
			local a = ...
			local helper = wesnoth.require("lua/helper.lua")
			local terrain = {wesnoth.get_terrain(a.x1, a.y2), wesnoth.get_terrain(a.x2, a.y2)}
			local map_size = wesnoth.get_variable("GN_LOCAL_MAP_SIZE")
			local keep_pos = { 2 + math.ceil(map_size/4), 2 + math.ceil(map_size/6) }

			local adjacent_offset = {
				[false] = { {0,-1}, {1,-1}, {1,0}, {0,1}, {-1,0}, {-1,-1} },
				[true] = { {0,-1}, {1,0}, {1,1}, {0,1}, {-1,1}, {-1,0} }
			}

			local function move(point, direction, distance)
				local even = point[1]%2 == 0
				if -1 < distance and distance < 1 then return point
				elseif distance > 0 then
					return move({ point[1] + adjacent_offset[even][direction][1],
							point[2] + adjacent_offset[even][direction][2] }, direction, distance - 1)
				else
					local opposite = (direction + 3) % 6
					return move({ point[1] + adjacent_offset[even][opposite][1],
							point[2] + adjacent_offset[even][opposite][2] }, opposite, 1 - distance)
				end
			end

			keep_offset = { [true] = {}, [false] = {}}
			for i = 1, 6 do
				keep_offset[true][i] = move({0,0}, i, map_size)
				keep_offset[false][i] = move({1, 0}, i, map_size)
				keep_offset[false][i][1] = keep_offset[false][i][1] - 1
			end
			
			local keep = { keep_pos, move(keep_pos, 3, map_size) }
			local map_dim = { x = keep[2][1] + keep_pos[1] - 1, y = keep[2][2] + keep_pos[2] - 1}

			--! Returns an iterator over adjacent locations that can be used in a for-in loop.
			local function adjacent_tiles(x, y)
				local offset = adjacent_offset[x%2 == 0]
				local i = 1
				return function()
					while i <= 6 do
						local o = offset[i]
						i = i + 1
						local u, v = o[1] + x, o[2] + y
						if u >= 1 and u <= map_dim.x and v >= 1 and v <= map_dim.y then
							return u, v
						end
					end
					return nil
				end
			end

			local map = {}
			for x = 0, map_dim.x + 1 do
				map[x]={}
				for y = 0, map_dim.y + 1 do
					map[x][y] = "Gg"
				end
			end

			local rd = keep_pos
			for i = 1,map_size do
				rd = move(rd, 3, 1)
				map[rd[1]][rd[2]] = "Rd"
			end

			for i = 1,2 do
				map[keep[i][1]][keep[i][2]] = "Ke"
				for x, y in adjacent_tiles(keep[i][1], keep[i][2]) do
					map[x][y] = "Ce"
				end
			end
			
			map_string = "border_size=1\nusage=map\n\n"
			for y = 0, map_dim.y + 1 do
				for x = 0, map_dim.x do
					map_string = map_string .. map[x][y] .. ','
				end
				map_string = map_string .. map[map_dim.x + 1][y] .. '\n'
			end

			wesnoth.set_variable("local_map", map_string)
			wesnoth.set_variable("GN_ATTACKER_X", keep[1][1])
			wesnoth.set_variable("GN_ATTACKER_Y", keep[1][2])
			wesnoth.set_variable("GN_DEFENDER_X", keep[2][1])
			wesnoth.set_variable("GN_DEFENDER_Y", keep[2][2])
		>>
	[/lua]
	[replace_map]
		map="$local_map|"
		expand=yes
		shrink=yes
	[/replace_map]
	{CLEAR_VARIABLE local_map}
#enddef
